

深度优先遍历
广度优先遍历

生成树 -> 最小生成树

prim(普里姆算法): 选择点
1.找到访问过(使用visit数组标记)和没有访问过的顶点的(n-1条)最小边并记录每次的顶点。


克鲁斯卡尔              : 选择边

n个顶点的图的集合V
U:已经在最小生成树上的顶点
V-U: 尚未在最小生成树上的顶点


各个城市建立通行网

                有向图
                 A B  C  D    E  F
            A   {0,1,12,MAX,MAX,MAX},
            B   {MAX,0,9,3,MAX,MAX},
            C   {MAX,MAX,0,MAX,5,MAX},
            D   {MAX,MAX,4,0,13,15},
            E   {MAX,MAX,MAX,MAX,0,4},
            F   {MAX,MAX,MAX,MAX,MAX,0}

1.以A为起点先初始化A到各个顶点的最小距离无法直达设为max dist [0,1,12,max,max,max] AA=0 AB=1 AC=12
2.选取离出发点最近且未标记的点，以该点为中心扩散寻找周边顶点的最小距离(广度优先算法)。如图找到B点，
  与B直接相邻的C D(除取出发节点) BC=9 BD=3 所以 AD=BD+dist[B] A到B的最小距离+B到D的最小距离就是A到D的最小距离
  此时AD=BD+dist[B] = 1+9 = 10  < dist[C] = 12 新计算出的AD距离小于原来的距离，此时更新dist [0,1,10,4,max,max]
3.以次类推下一个顶点选取除了A和B且距离出发点A最近的点D=4 所以下一个顶点为D,直接相邻的 DC=4 DF=15 DE=13
  AC=dist[D] + DC = 4 + 4 = 8 < dist[C] = 10  先到达d在到c的距离小于原来AC直达的距离等等需要更新dist
  AF=dist[D] + DF = 4 + 15 = 19 < max
  AE=dist[E] + DE = 4 + 13 = 17 < max
  此时根据比较 dist更新为 [0,1,8,4,17,19]
3.以此类推下一个顶点为C (去除ABD最短的)
  AE = CE + dist[C] =  5 + 8=13 < 17 更新dist
  此时根据比较dist更新为 [0,1,8,4,13,19]
3.以次类推下一个顶点E (去除ABCD)
  AF = EF + dist[E] = 4 + 13 = 17 < 19 所以更新dist
3.以次类推下一个顶点F (去除ABCDE)
  图为有向图，F不能到达任何顶点 (只能别的顶点到达它) 所以dist不做更新
4.得到dist[0,1,8,4,13,17] 即为A到达各个顶点的距离